[{"title":"python","url":"/2024/07/25/library-docs/Python/","content":"\n# 基本概念\n\n![](img/data.png)\n\n格式化输出\n\n```python\n# 格式化输出，两种方式一样\nname = '刘艳艳'\nage = 36\nprint('我喜欢人是{},她今年{}'.format(name, age))\nprint(f'我喜欢的是{name},她今年{age}')\n# 转义字符\nprint(f'我喜欢的是\\t{name}\\n她今年{age}')\n# 默认print后面自带end='\\n'换行，这里自己修改成tab制表符\nprint('i love yy',end='\\t')\nprint('lgy')\n```\n\n类型转换\n\n```python\n# eval内置函数把字符串转换其原本格式\n# 对应上面图片中类型如果加了引号是字符串的话用eval可以直接还原原本格式\nx1 = '(1000, 2000, 3000)'\nx2 = '4.5'\nprint(f'x1是{eval(x1)}\\t格式{type(eval(x1))}\\nx2是{eval(x2)}\\t格式{type(eval(x2))}')\n```\n\n# 流程控制\n\nif条件语句\n\n```python\nage = int(input('请输入您的年龄：'))\nif age < 18:\n    print(f'您的年龄是{age},童工一枚')\nelif (age >= 18) and (age <= 60):\n    print(f'您的年龄是{age},合法工龄')\nelif 60 < age < 100:\n    print(f'您的年龄是{age},可以退休')\nelse:\n    print('超过限值')\n```\n\n三目运算符\n\n```python\na = 1\nb = 2\nc = a if a > b else b\nprint(c)\n```\n\nwhile循环\n\n```python\nnum = 0\nwhile num < 10:\n    print(num)\n    num += 1\n```\n\nfor循环\n\n```python\nfor i in range(10):\n    print(i)\n```\n\n# 序列数据\n\n## 列表\n\n```python\nname_list = ['lgy', 'lyy', 'lgl', 'lyy']\n# 指定数据所在位置,后面两参数表示搜索开始的列表索引（包含）以及是搜索结束的列表索引（不包含）\nprint(name_list.index('lyy', 2, 4))\n# 统计次数\nprint(name_list.count('lyy'))\n# 列表长度\nprint(len(name_list))\n# 判断是否存在\nprint('lyy' in name_list, 'Lyy' not in name_list)\n# 增加数据\nname_list.append('刘国燕')\n# 如果增加的数据是一个列表,把该数据逐一加入\nname_list.extend(name_list)\nprint(name_list)\n# 在指定位置插入数据\nname_list.insert(0,'刘艳艳')\nprint(name_list)\n# 删除指定位置数据\ndel name_list[0]\n# 删除指定数据,移除第一个符合条件的\nname_list.remove('刘国燕')\nprint(name_list)\n# 修改数据\nname_list[-1] = 'LiuGuoYan'\nprint(name_list)\n# 倒着输出\nname_list.reverse()\nprint(name_list)\n# 清空列表\nname_list.clear()\n```\n\n列表的sort函数\n\n```python\n# 定义一个函数，用于提取字符串的长度作为排序的关键字\ndef get_length(s):\n    return len(s)\n# 原始列表\nfruits = ['apple', 'banana', 'cherry', 'orange']\n# 使用关键字参数 key 来指定排序的规则，按照字符串长度排序\nfruits.sort(key=get_length, reverse=True)\nprint(fruits)\n```\n\n## 元组和集合\n\n元组操作和列表差不多，差别在于元组不允许修改数值\n\n```python\n# 会报错，元组内数据不能更改\nx = (10,20)\nx[0] = 1\n```\n\n集合可以去掉重复数据，集合数据是无序的，故不支持下标\n\n集合也支持判断数据在不在序列的in，not in 操作\n\n```python\n# 用集合去重\nx = [1, 2, 3, 3, 4, 5, 1]\nprint(set(x))\n# 创建集合\ny = {2, 3, 4, 5, 2}\n# 增加数据\ny.add(11)\n# 删除数据\ny.remove(4)\nprint(y)\n```\n\n## 字典\n\n```python\ndict_ = {'name': 'lyy', 'age': 36, 'gender': '女'}\n# 修改值,如果键不存在则新增\ndict_['name'] = 'Lyy'\ndict_['location'] = 'JiuTing'\nprint(dict_)\n# 查找值,第一种方法如果不存键会报错，第二种方法不存在会返回自定义的一个数\nprint(dict_['name'])\nprint(dict_.get('name2', None))\n# 删除\ndel dict_['location']\n# 遍历字典\nfor item in dict_.items():\n    print(item)\n# 遍历键值对\nfor key, value in dict_.items():\n    print(f'{key} = {value}')\n# 字典去重合并，后面相同键数据会覆盖前者\npostgres_dict = {'a':1,'b':2}\nredis_dict = {'a':2,'c':5}\nprint({**postgres_dict, **redis_dict})\n```\n\n## 字符串\n\n```python\nstr_ = 'i love lyy love lgl'\n# 查找位置,原理同列表\nprint(str_.find('love', 0, 10))\n# 从右边开始查找\nprint(str_.rfind('love', 0, len(str_)))\n# replace\nprint(str_.replace('love', 'like'))\n# 拆分\nprint(str_.split(' '))\n# 在一个序列中插入一个字符\n# 这里返回i_love_lyy,这样一个字符串\nprint('_'.join(['i', 'love', 'lyy']))\n# 大小写转换\n# 第一个字大写\nprint(str_.capitalize())\n# 每个单词第一个字大写\nprint(str_.title())\n# 全部大写\nprint(str_.upper())\n# 全部小写\nprint(str_.lower())\n# lstrip():删除字符串左侧空白字符\n# rstrip():删除字符串右侧空白字符\n# strip():删除字符串两侧空白字符\n# isalpha():字符串至少有一个字符并且都是字母\n# isdigit():字符串只能包含数字\n```\n\n## 公共方法\n\n| 函数                      | 描述                                                              |\n| ----------------------- | --------------------------------------------------------------- |\n| len()                   | 计算容器中元素个数                                                       |\n| del 或 del()             | 删除                                                              |\n| max()                   | 返回容器中元素最大值                                                      |\n| min()                   | 返回容器中元素最小值                                                      |\n| range(start, end, step) | 生成从start到end的数字，步长为 step，供for循环使用                               |\n| enumerate()             | 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。 |\n\n```python\n# 这里i就是序号从0到2，j就是列表中数据\nfor i, j in enumerate(['lyy','lgl','lgy']):\n    print(f'index={i},value={j}')\n```\n\n## 推导式\n\n```python\n# 列表推导式\nlist1 = [(i, j) for i in range(10) for j in range(10) if i % 2 == 0 and j % 2 == 0]\nprint(list1)\n# 字典推导式\nlist1 = ['name', 'age', 'gender']\nlist2 = ['Tom', 20, 'man']\ndict1 = {list1[i]: list2[i] for i in range(len(list1))}\nprint(dict1)\n```\n\n# 函数\n\n## 全局变量\n\nglobal关键字声明x是全局变量\n\n```python\nx = 10\ndef fun():\n    global x\n    x = 20\nfun()\nprint(x)\n```\n\n## 参数\n\n**args**：它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递\n\n```python\ndef test(x, *args):\n    print(x, args)\ntest(1,2,3,4)\n# 输出1 (2, 3, 4)\n```\n\n**kargs**：根据传进参数的位置合并为一个字典，这叫包裹参数传递\n\n```python\ndef test(**kwargs):\n    print(kwargs)\ntest(name='lyy', age=36, id=110)\n# 输出{'name': 'lyy', 'age': 36, 'id': 110}\n```\n\n提示函数传参和返回值类型，这个只是增加代码可读性但不是强制类型\n\n```python\ndef add(x: int, y: int) -> int:\n    \"\"\"\n    This function takes two integers as input and returns their sum.\n    \"\"\"\n    return x + y\n```\n\nlambda表达式\n\n如果一个函数有一个返回值，并且只有一句代码，可以使用 lambda简化\n\n```python\n# lambda 参数列表：表达式\nfn1 = lambda a, b: a + b\nprint(fn1(1, 2))\n```\n\n## 高阶函数\n\n把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式\n\n```python\ndef sum_num(a, b, f):\n    return f(a) + f(b)\n# 把函数当作参数传入\nresult = sum_num(-1, 2, abs)\nprint(result)\n```\n\n自定义函数\n\n```python\ndef fun1(x,y):\n    return y(x)\ndef fun2(i):\n    return i**2\nprint(fun1(5,fun2))\n```\n\n##  回调函数\n\n回调函数是指在某个特定事件发生时被调用的函数。在 Python 中，回调函数通常是作为参数传递给其他函数，以便在需要时执行\n\n```shell\ndef button_click(callback):\n    # 模拟按钮点击事件\n    print(\"Button clicked!\")\n    # 调用回调函数\n    callback()\n\ndef my_callback():\n    print(\"Callback function called!\")\n\n# 将 my_callback 函数作为回调函数传递给 button_click\nbutton_click(my_callback)\n```\n\n下面案例模式在事件驱动编程中非常常见，可以用于处理异步操作、事件监听等场景\n\n```python\nclass Api:\n    def __init__(self):\n        self.obj = None\n    def register_callback(self, obj):\n        self.obj = obj\n    def execute(self):\n        print(\"A: Executing function...\")\n        # 当A的执行函数完成后，调用回调函数\n        if self.obj:\n            print(\"A: Triggering callback...\")\n            self.obj.On_callback()\nclass Spi:\n    def __init__(self):\n        pass\n    def On_callback(self):\n        print(\"B: Callback function is called!\")\n# 实例化对象\napi = Api()\nspi = Spi()\n# 注册回调对象\napi.register_callback(spi)\n# 执行A的函数，这将触发B的回调函数\napi.execute()\n```\n\n## 装饰器\n\n装饰器（Decorator）是一种Python语法，用于动态地修改函数或类的行为。装饰器允许你在不修改原始函数或类定义的情况下，对它们进行包装或扩展\n\n下面例子装饰器作用其实和最下面func3效果一样，正常我们要增加内容需要对函数里面添加内容，这样不方便但是用装饰器我们可以把增加的功能单独封装到到一个函数\n\n装饰器运行时候直接运行my_decorator函数，然后该函数内执行对应传入的func函数\n\n```python\ndef my_decorator(func):\n    def wrapper(*args):\n        print(args, 'lyy')\n        result = func(*args)\n        print(args, 'lgy')\n        return result\n    return wrapper\n@my_decorator\ndef func1(x, y):\n    return x + y\n@my_decorator\ndef func2(x, y, z):\n    return x * y * z\na = func1(1, 2)\nb = func2(4, 5, 6)\nprint(a, b)\n\n\ndef func3(x, y):\n    print(x, y, 'lyy')\n    result = x + y\n    print(x, y, 'lgy')\n    return result\nc = func3(1, 2)\nprint(c)\n```\n\n### 装饰器实例\n\n函数执行时间\n\n```python\nimport time\ndef timer(func):\n    def wrapper(*args,**kwargs):\n        start_time = time.time()\n        result = func(*args,**kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time-start_time} seconds\")\n        return result\n    return wrapper\n@timer\ndef func1():\n    print(5)\n    time.sleep(5)\nfunc1()\n```\n\n记录函数返回值，不过只能字符串\n\n```python\nimport time\ndef log_results(func):\n    def wrapper(*args,**kwargs):\n        result = func(*args,**kwargs)\n        with open('D:/log.log','a') as log_file:\n            log_file.write(f\"{func.__name__} Result: {result}\\n\")\n        return result\n    return wrapper\n@log_results\ndef func1():\n    x = 5\n    y = 10\n    return x+y\nfunc1()\n```\n\n\n\n# 面向对象\n\n## 魔法方法\n\n- `__init__()`: 初始化\n- `__str__()`:输出对象信息\n- `__del__()`:删除对象时调用\n- `__call__()`:当对象被作为函数调用时触发\n\n```python\nclass Lyy:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return '输出了__str__'\n\n    def __del__(self):\n        print('对象销毁了')\n\n    def __call__(self, x):\n        return x*2name\n    \n\tdef __len__(self):\n        return len(self.name)\nl1 = Lyy('刘国燕', 36)\n# 输出对象时候会调用__str__的返回值，正常情况下会返回对象地址\nprint(l1)\n# 对象直接当作函数使用传参\nprint(l1(2))\n# 可直接使用len\nprint(len(l1))\n```\n\n## 继承\n\n单继承看下面例子，另外也支持多继承即一个类继承多个类，形式如class C(B,A)\n\n这样可以同时使用B和A类里各自的方法，如果方法同名则使用第一个类B的方法。\n\n下例中super()表示调用父类方法\n\n```python\nclass A:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def out(self):\n        print(self.name, self.age)\n\n\nclass B(A):\n    def __init__(self, name, age):\n        super().__init__(name, age)\n\n    def out(self):\n        super().out()\n        print('重写了方法')\n\n\nl1 = B('刘国燕', 36)\nl1.out()\n```\n\n设置私有权限的方法：在属性名和方法名 前面 加上两个下划线 __\n\n私有属性和私有方法只能在类里面访问和修改，不能被对象访问也不能被继承\n\n下面例子中加了__的属性和方法，要通过类中其他方法才能调用直接调用会报错\n\n```python\nclass A:\n    def __init__(self, name, age):\n        self.name = name\n        self.__age = age\n\n    def __out(self):\n        print(self.name, self.__age)\n\n    def get_local_fun(self):\n        self.__out()\n\n    def get_local_attribute(self):\n        return self.__age\n\n\nl1 = A('刘国燕', 36)\n# l1.__out() 不能访问\n# print(l1.__age) 不能访问\nl1.get_local_fun()\nprint(l1.get_local_attribute())\n```\n\n## 多态\n\n多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）\n\n实现步骤：\n\n- 定义父类，并提供公共方法\n- 定义子类，并重写父类方法\n- 传递子类对象给调用者，可以看到不同子类执行效果不同\n\n下面例子，我们重新定义两个子类ad和dd，在调用person中我们传入不同子类对象，可以获得不同的对象方法\n\n```python\nclass Dog(object):\n    def work(self):  # 父类提供统一的方法，哪怕是空方法\n        print('指哪打哪...')\n\n\nclass ArmyDog(Dog):  # 继承Dog类\n    def work(self):  # 子类重写父类同名方法\n        print('追击敌人...')\n\n\nclass DrugDog(Dog):\n    def work(self):\n        print('追查毒品...')\n\n\nclass Person(object):\n    def work_with_dog(self, dog):  # 传入不同的对象，执行不同的代码，即不同的work函数\n        dog.work()\n\n\nad = ArmyDog()\ndd = DrugDog()\n\ndaqiu = Person()\ndaqiu.work_with_dog(ad)\ndaqiu.work_with_dog(dd)\n```\n\n## 类属性和类方法\n\n- 类属性就是 **类** 所拥有的属性，它被 **该类的所有实例对象 所共有**。\n- 类属性可以使用 **类对象** 或 **实例对象** 访问\n- 类属性只能通过类对象修改，不能通过实例对象修改，如果通过实例对象修改类属性，表示的是创建了一个实例属性\n\n```python\nclass Lyy:\n    num = 10\nl1 = Lyy()\nl2 = Lyy()\nLyy.num = 10\nl1.num = 1\nprint(Lyy.num, l2.num, l1.num)\n```\n\n需要用装饰器`@classmethod`来标识其为类方法，对于类方法，**第一个参数必须是类对象**，一般以`cls`作为第一个参数\n\n- 当方法中 **需要使用类对象** (如访问私有类属性等)时，定义类方法\n- 类方法一般和类属性配合使用\n- 可以通过类和实例对象访问\n\n```python\nclass Lyy:\n    num = 10\n    @classmethod\n    def get(cls):\n        print('方法', cls.num)\nl1 = Lyy()\nLyy.get()\nl1.get()\n```\n\n## 静态方法\n\n静态方法通过使用 `@staticmethod` 装饰器来声明，通常在类的内部，但不需要访问类或实例的属性或方法时使用。静态方法可以直接通过类名调用，也可以通过实例调用。\n\n```python\nclass Lyy:\n    @staticmethod\n    def get():\n        print('静态方法')\nl1 = Lyy()\nLyy.get()\nl1.get()\n```\n\n## 抽象类\n\n抽象类（Abstract class）是一种不能被直接实例化的类，它只能被继承并在子类中实现具体方法。抽象类通常包含了一些抽象方法（Abstract method），这些方法在抽象类中只有方法签名而没有具体的实现。\n\n抽象类的主要作用是定义了一些通用的接口和行为，但是并不提供具体的实现。它通过强制子类去实现抽象方法，从而确保了子类具有相同的接口，并且强制了子类去实现一些必要的行为。抽象类常常用于描述一些概念性的、通用的类，而具体的实现则留给其子类去完成\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass AbstractClass(ABC):\n    @abstractmethod\n    def abstract_method(self):\n        pass\n\nclass ConcreteClass(AbstractClass):\n    def abstract_method(self):\n        print(\"Concrete implementation of abstract method\")\n\n# 尝试实例化抽象类，会抛出错误\n# abstract_obj = AbstractClass()\n\n# 实例化子类\nconcrete_obj = ConcreteClass()\n# 调用子类实现的方法\nconcrete_obj.abstract_method()\n```\n\n# looging\n\n```python\nimport logging\n\n# 配置日志记录器\nlogging.basicConfig(filename='example.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')\n\ndef main():\n    logging.debug('这是一个调试消息')\n    logging.info('这是一个信息消息')\n    logging.warning('这是一个警告消息')\n    logging.error('这是一个错误消息')\n    logging.critical('这是一个严重错误消息')\n\nif __name__ == '__main__':\n    main()\n\n```\n\n# 包管理\n\n新建一个my_package文件夹，里面新建一个init的文件，该文件会让Python将这个文件夹识别为一个包\n\n该文件夹下有如下两个文件\n\n```python\n# model1.py\ndef fun():\n    print('lyy')\nclass Lyy:\n    def __init__(self):\n        print('Lyy初始化了')\n# __init__.py\nfrom .model1 import fun\nfrom .model1 import Lyy\nglobals_num = 1\n```\n\n此时在文件夹外部我们可以通过如下代码直接导入需要的函数和对象\n\n```python\nimport my_package\nmy_package.fun()\nprint(my_package.globals_num)\na = my_package.Lyy()\n```\n\n","tags":["计算机","python"],"categories":["computer"]},{"title":"ctp报单","url":"/2024/07/25/quant/ctp2/","content":"\n# 报单\n\n报单需要参数会非常多，基本必须的设置如下，不过大部分可能不会用到，下面是固定数值的基本就说明这个不用传参直接默认掉就行了，比如投机还是套保不开发套保功能所以默认只有投机就行了\n\n```python\norderfield = tdapi.CThostFtdcInputOrderField()\n# 账户信息\norderfield.BrokerID = login_info['BrokerID']\norderfield.InvestorID = login_info['UserID']\n# 合约信息\norderfield.ExchangeID = ExchangeID\norderfield.InstrumentID = InstrumentID\n\"\"\"下单信息\"\"\"\n# 开平标记\norderfield.CombOffsetFlag = CombOffsetFlag\n# 买卖方向\norderfield.Direction = Direction\n# 数量\norderfield.VolumeTotalOriginal = VolumeTotalOriginal\n# 报单价格条件\norderfield.OrderPriceType = OrderPriceType\n# 价格\norderfield.LimitPrice = LimitPrice\n# 投机套保标志\norderfield.CombHedgeFlag = \"1\"\n# 触发条件\norderfield.ContingentCondition = \"1\"\n# 有效期类型\norderfield.TimeCondition = \"3\"\n# 强平原因\norderfield.ForceCloseReason = \"0\"\n# 自动挂起标志\norderfield.IsAutoSuspend = 0\n# 成交量类型\norderfield.VolumeCondition = \"1\"\n# 互换单标志\norderfield.IsSwapOrder = 0\n# 止损价，不使用不影响\n# orderfield.StopPrice = 0\n# 报单引用，如果不需要自己指定这个属性不设置\norderfield.OrderRef = OrderRef\n```\n\n## 关键参数说明\n\nCombOffsetFlag：开平标记\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcOffsetFlagType是一个开平标志类型\n/////////////////////////////////////////////////////////////////////////\n///开仓\n#define THOST_FTDC_OF_Open '0'\n///平仓\n#define THOST_FTDC_OF_Close '1'\n///强平\n#define THOST_FTDC_OF_ForceClose '2'\n///平今\n#define THOST_FTDC_OF_CloseToday '3'\n///平昨\n#define THOST_FTDC_OF_CloseYesterday '4'\n///强减\n#define THOST_FTDC_OF_ForceOff '5'\n///本地强平\n#define THOST_FTDC_OF_LocalForceClose '6'\n```\n\nDirection：买卖方向\n\n```c++\n///TFtdcDirectionType是一个买卖方向类型\n/////////////////////////////////////////////////////////////////////////\n///买\n#define THOST_FTDC_D_Buy '0'\n///卖\n#define THOST_FTDC_D_Sell '1'\n```\n\nOrderPriceType：报单价格类型\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcOrderPriceTypeType是一个报单价格条件类型\n/////////////////////////////////////////////////////////////////////////\n///任意价\n#define THOST_FTDC_OPT_AnyPrice '1'\n///限价\n#define THOST_FTDC_OPT_LimitPrice '2'\n///最优价\n#define THOST_FTDC_OPT_BestPrice '3'\n///最新价\n#define THOST_FTDC_OPT_LastPrice '4'\n///最新价浮动上浮1个ticks\n#define THOST_FTDC_OPT_LastPricePlusOneTicks '5'\n///最新价浮动上浮2个ticks\n#define THOST_FTDC_OPT_LastPricePlusTwoTicks '6'\n///最新价浮动上浮3个ticks\n#define THOST_FTDC_OPT_LastPricePlusThreeTicks '7'\n///卖一价\n#define THOST_FTDC_OPT_AskPrice1 '8'\n///卖一价浮动上浮1个ticks\n#define THOST_FTDC_OPT_AskPrice1PlusOneTicks '9'\n///卖一价浮动上浮2个ticks\n#define THOST_FTDC_OPT_AskPrice1PlusTwoTicks 'A'\n///卖一价浮动上浮3个ticks\n#define THOST_FTDC_OPT_AskPrice1PlusThreeTicks 'B'\n///买一价\n#define THOST_FTDC_OPT_BidPrice1 'C'\n///买一价浮动上浮1个ticks\n#define THOST_FTDC_OPT_BidPrice1PlusOneTicks 'D'\n///买一价浮动上浮2个ticks\n#define THOST_FTDC_OPT_BidPrice1PlusTwoTicks 'E'\n///买一价浮动上浮3个ticks\n#define THOST_FTDC_OPT_BidPrice1PlusThreeTicks 'F'\n///五档价\n#define THOST_FTDC_OPT_FiveLevelPrice 'G'\n```\n\nContingentCondition：触发条件\n\nStopPrice：止损价，其实就是条件价\n\n1. 一般填写THOST_FTDC_CC_Immediately， 即报单立即有效\n2. THOST_FTDC_CC_Touch和THOST_FTDC_CC_TouchProfit是止损止盈单，需要交易所支持才能填\n3. THOST_FTDC_CC_ParkedOrder是预埋单。预埋单是指预埋在CTP服务端，需要非交易时间报入，开市后自动发出\n4. 其他枚举类型则为条件单，报单后存入CTP服务端，CTP判断条件达到后自动报入交易所\n5. 当参数是'5'后面时候就是条件单，此时还需要设置StopPrice这个就是条件价\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcContingentConditionType是一个触发条件类型\n/////////////////////////////////////////////////////////////////////////\n///立即\n#define THOST_FTDC_CC_Immediately '1'\n///止损\n#define THOST_FTDC_CC_Touch '2'\n///止赢\n#define THOST_FTDC_CC_TouchProfit '3'\n///预埋单\n#define THOST_FTDC_CC_ParkedOrder '4'\n///最新价大于条件价\n#define THOST_FTDC_CC_LastPriceGreaterThanStopPrice '5'\n///最新价大于等于条件价\n#define THOST_FTDC_CC_LastPriceGreaterEqualStopPrice '6'\n///最新价小于条件价\n#define THOST_FTDC_CC_LastPriceLesserThanStopPrice '7'\n///最新价小于等于条件价\n#define THOST_FTDC_CC_LastPriceLesserEqualStopPrice '8'\n///卖一价大于条件价\n#define THOST_FTDC_CC_AskPriceGreaterThanStopPrice '9'\n///卖一价大于等于条件价\n#define THOST_FTDC_CC_AskPriceGreaterEqualStopPrice 'A'\n///卖一价小于条件价\n#define THOST_FTDC_CC_AskPriceLesserThanStopPrice 'B'\n///卖一价小于等于条件价\n#define THOST_FTDC_CC_AskPriceLesserEqualStopPrice 'C'\n///买一价大于条件价\n#define THOST_FTDC_CC_BidPriceGreaterThanStopPrice 'D'\n///买一价大于等于条件价\n#define THOST_FTDC_CC_BidPriceGreaterEqualStopPrice 'E'\n///买一价小于条件价\n#define THOST_FTDC_CC_BidPriceLesserThanStopPrice 'F'\n///买一价小于等于条件价\n#define THOST_FTDC_CC_BidPriceLesserEqualStopPrice 'H'\n```\n\nTimeCondition：有效期类型\nVolumeCondition：成交量类型\nMinVolume：最小成交量，一个int类型自己填写\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcTimeConditionType是一个有效期类型类型\n/////////////////////////////////////////////////////////////////////////\n///立即完成，否则撤销\n#define THOST_FTDC_TC_IOC '1'\n///本节有效\n#define THOST_FTDC_TC_GFS '2'\n///当日有效\n#define THOST_FTDC_TC_GFD '3'\n///指定日期前有效\n#define THOST_FTDC_TC_GTD '4'\n///撤销前有效\n#define THOST_FTDC_TC_GTC '5'\n///集合竞价有效\n#define THOST_FTDC_TC_GFA '6'\n/////////////////////////////////////////////////////////////////////////\n///TFtdcVolumeConditionType是一个成交量类型类型\n/////////////////////////////////////////////////////////////////////////\n///任何数量\n#define THOST_FTDC_VC_AV '1'\n///最小数量\n#define THOST_FTDC_VC_MV '2'\n///全部数量\n#define THOST_FTDC_VC_CV '3'\n```\n\n上面三个参数组合起来就可以达到fak和fok的命令，组合方式参考下面表格\n\n|      字段       |       普通        |                             FAK                              |        FOK        |\n| :-------------: | :---------------: | :----------------------------------------------------------: | :---------------: |\n|  TimeCondition  | THOST_FTDC_TC_GFD |                      THOST_FTDC_TC_IOC                       | THOST_FTDC_TC_IOC |\n| VolumeCondition | THOST_FTDC_VC_AV  |              THOST_FTDC_VC_AV/THOST_FTDC_VC_MV               | THOST_FTDC_VC_CV  |\n|    MinVolume    |     不需要填      | 如果VolumeCondition为THOST_FTDC_VC_AV，则不需要填。如果为THOST_FTDC_VC_MV，则设为要求的最小成交的手数 |     不需要填      |\n\n# 报单回报\n\n报单回报的来回图见图片，这里说明几个常见属性\n\n```python\n_dict = {'InsertTime': pOrder.InsertTime,\n         'InstrumentID': pOrder.InstrumentID,\n         'OrderStatus': pOrder.OrderStatus, \n         'OrderSubmitStatus': pOrder.OrderSubmitStatus,\n         'CombOffsetFlag': pOrder.CombOffsetFlag, \n         'Direction': pOrder.Direction,\n         'LimitPrice': pOrder.LimitPrice,\n         'VolumeTotalOriginal': pOrder.VolumeTotalOriginal,\n         'VolumeTraded': pOrder.VolumeTraded,\n         'VolumeTotal': pOrder.VolumeTotal,\n         'OrderRef': pOrder.OrderRef,\n         'OrderSysID': pOrder.OrderSysID\n        }\n```\n\nOrderStatus：报单状态\n\n一般报单回报过来流程就是'a'->'3'->'1'或者'0'，如果执行撤单也会走'3'->'5'\n\n状态3和5的回报，都不会对实际持仓发送改变，仅仅变化的是挂单，只有发送1或者0的时候才是真实持仓有变动了\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcOrderStatusType是一个报单状态类型\n/////////////////////////////////////////////////////////////////////////\n///全部成交\n#define THOST_FTDC_OST_AllTraded '0'\n///部分成交还在队列中\n#define THOST_FTDC_OST_PartTradedQueueing '1'\n///部分成交不在队列中\n#define THOST_FTDC_OST_PartTradedNotQueueing '2'\n///未成交还在队列中\n#define THOST_FTDC_OST_NoTradeQueueing '3'\n///未成交不在队列中\n#define THOST_FTDC_OST_NoTradeNotQueueing '4'\n///撤单\n#define THOST_FTDC_OST_Canceled '5'\n///未知\n#define THOST_FTDC_OST_Unknown 'a'\n///尚未触发\n#define THOST_FTDC_OST_NotTouched 'b'\n///已触发\n#define THOST_FTDC_OST_Touched 'c'\n```\n\nCombOffsetFlag：组合开平标志\nCombHedgeFlag：组合投机套保标志\n\n```c++\n/////////////////////////////////////////////////////////////////////////\n///TFtdcOffsetFlagType是一个开平标志类型\n/////////////////////////////////////////////////////////////////////////\n///开仓\n#define THOST_FTDC_OF_Open '0'\n///平仓\n#define THOST_FTDC_OF_Close '1'\n///强平\n#define THOST_FTDC_OF_ForceClose '2'\n///平今\n#define THOST_FTDC_OF_CloseToday '3'\n///平昨\n#define THOST_FTDC_OF_CloseYesterday '4'\n///强减\n#define THOST_FTDC_OF_ForceOff '5'\n///本地强平\n#define THOST_FTDC_OF_LocalForceClose '6'\n/////////////////////////////////////////////////////////////////////////\n///TFtdcHedgeFlagType是一个投机套保标志类型\n/////////////////////////////////////////////////////////////////////////\n///投机\n#define THOST_FTDC_HF_Speculation '1'\n///套利\n#define THOST_FTDC_HF_Arbitrage '2'\n///套保\n#define THOST_FTDC_HF_Hedge '3'\n///做市商\n#define THOST_FTDC_HF_MarketMaker '5'\n///第一腿投机第二腿套保\n#define THOST_FTDC_HF_SpecHedge '6'\n///第一腿套保第二腿投机\n#define THOST_FTDC_HF_HedgeSpec '7'\n```\n\n","tags":["计算机","ctp","金融"],"categories":["finance"]},{"title":"ctp登录、查询","url":"/2024/07/25/quant/ctp1/","content":"\n# 登录\n\nSpi （如 CThostFtdcTraderSpi），包含有所有的响应和回报函数，用于接收综合交易平台发送或交易所发送 综合交易平台转发的信息。开发者需要继承该接口类，并实现其中相应的虚函数\n\nApi （如 CThostFtdcTraderApi），包含主动发起请求和订阅的接口函数，开发者直接调用即可\n\n上面是官方文档中的介绍，我们使用时候就是创建api和spi的实例对象即可。所有动作额执行都是通过api发送请求出去，然后ctp柜台接到请求把处理结果通过spi的回调函数返回给客户端，我们的实现逻辑就是重写这些回调函数\n\n## **ctp准备工作**\n\n1、创建api实例\n\n2、创建spi实例\n\n3、把spi对象注册进api中\n\n4、设置前置交易地址，订阅公有流和私有流\n\n5、初始化函数Init()，调用后,接口才开始发起前置的连接请求\n\n```python\ntraderapi = tdapi.CThostFtdcTraderApi_CreateFtdcTraderApi()\ntraderspi = CTraderSpi(traderapi)\ntraderapi.RegisterSpi(traderspi)\ntraderapi.RegisterFront(login_info['Trade Front'])\ntraderapi.SubscribePrivateTopic(tdapi.THOST_TERT_QUICK)\ntraderapi.SubscribePublicTopic(tdapi.THOST_TERT_QUICK)\ntraderapi.Init()\n```\n\n上面是python的程序，其中CTraderSpi自建的类\n\n## **ctp登录流程**\n\n1、OnFrontConnected：初始化链接后响应函数，然后这里去执行api.ReqAuthenticate\n\n2、OnRspAuthenticate：客户端认证回调，在里面再去执行登录动作api.ReqUserLogin\n\n3、OnRspUserLogin：登录响应，每天第一次需要确认结算单，这里再去执行api.ReqSettlementInfoConfirm\n\n4、OnRspSettlementInfoConfirm：结算确认响应，这一步其实不需要，到这一步ctp内部的登录流程就走完了\n\n## **属性说明**\n\n1、GetTradingDay：这个是api中自带的方法，通过它可以返回当前交易日，对于夜盘晚上会返回下个交易日，如当天是否确认结算单等就可以靠这个来标记\n\n2、FrontID, SessionID：这两个属性在OnRspUserLogin回报中返回，分别是前置编号和会话编号，其中后者每次重新登录都会不同并且是递增的。许多人撤单会使用 FrontID + SessionID + OrderRef 撤单的方式，不过我个人喜好第二种方式不使用这两个ID而是采用柜台实际编号的方式，具体后面下单环节再细说。我自己目前只是把这两个ID加上前面的交易日组合成本地初始的OrderRef来使用，后续下单时候从OrderRef这个字段读取然后自增1，其他地方没怎么使用\n\n\n\n总体来说ctp登录账户还是比较简单的，可以看到就是一个api函数，然后spi中受到回报进行处理，其实整个ctp的所有操作都是这样一个流程，只要把握好回调函数中各种数据属性及自己本地的落地如何保存就行了\n\n# 查询\n\nctp中有所谓流控机制，有分为报单流控、查询流控等。报单流控一般不会触发，至少一秒几笔还是可以达到的，但是查询流控就比较恶心\n\n自从穿透式监管版本以后，API在连接交易前置时，会去查询到前置的查询流控设置（该设置配置在front_se组件）。假设前置配置了2笔/秒，那么连接该前置的API每秒只能发起2笔查询请求。\n\n但是要注意，不管怎么配置，API都内置了在途流控，在途查询流控为1笔。即，当前这笔查询请求发出后，在未收完所有的查询响应前，不能发起下一笔查询请求。\n\n在过去，查询流控是内置在API里，1笔每秒，在途1笔。\n\n如果超过交易前置配置的查询流控，则会触发OnRspError，并提示：“CTP：查询未就绪，请稍后重试”\n\n如果超过API内置的在途流控，则查询请求的返回值为-2，表示未处理请求超过许可数。\n\n以上是官方文档中的说明，可以看到是没办法支持连续查询的，所以对于偏高频多品种同时交易，成交后去查询持仓这个操作是一定会触发流控的。解决方法可以在返回值非0时候扔到一个队列中，外面专门开一个线程去队列里取值再次查询，或者建立一个while的循环，连续循环比如10次，每次返回失败延迟1秒再去查，查询成功跳出循环结束执行\n\n个人目前是采用第二种方案，然后在报单成交后查持仓这个动作是直接通过队列专门查询的，以防止查持仓这个动作的延迟影响整个回报函数中接受信息的延迟\n\n## **查持仓**\n\n通过查询函数ReqQryInvestorPosition执行后，回调函数OnRspQryInvestorPosition返回持仓信息，ctp的返回是一条记录一条记录的返回的，对于上期的话今仓和老仓是算作两条持仓分别返回\n\nReqQryInvestorPosition这个函数的参数结构中如果带上品种合约，则会返回该品种的持仓，如果不设置品种合约，则返回所有持仓合约\n\n下面重点看下回调函数的返回值\n\nPositionDate：持仓日期，‘1’表示当前交易日持仓    ‘2’表示是历史仓（只有上期和能源有这个值）\n\nPosiDirection：是枚举值，'2'表示多头持仓   '3'表示空头持仓\n\n通过这两个属性就能知道当前品种的仓位情况，所以本地构建数据结构名时候就需要根据这两个进行处理。个人使用的方法是把这两个属性相在加上品种代码就得到对应的持仓名称，PositionDate+PosiDirection+InstrumentID\n\n比如：12:rb2410就可以表示螺纹钢10合约的多头今仓\n\n除上期所品种: 12表示多头持仓，13表示空头持仓\n\n上期所品种: 12表示多头今天仓，13表示空头今天仓，22表示多头老仓，23表示空头老仓\n\n而头寸的具体信息这边保存字典格式如下\n\n```python\ndict_ = {\n        '总持仓': pInvestorPosition.Position,\n        '今持仓': pInvestorPosition.TodayPosition,\n        '持仓盈亏': pInvestorPosition.PositionProfit,\n        '多头冻结': pInvestorPosition.LongFrozen,\n        '空头冻结': pInvestorPosition.ShortFrozen,\n        '保证金': pInvestorPosition.UseMargin,\n        '持仓成本': pInvestorPosition.PositionCost,\n        '开仓成本': pInvestorPosition.OpenCost\n\t\t}\n```\n\n对于上海的品种，老仓下只有Position没有TodayPosition，而今仓下Position和TodayPosition是相等的\n\n对于非上海品种，Position就是总的持仓，而TodayPosition就表示今仓\n\n所以我们平仓时候判断持仓直接去读Position就可以了，一般不用理会今仓\n\n多头冻结和空头冻结：这两是挂单的意思\n\n对于多头持仓，多头冻结就是开仓未成交，空头冻结是平多未成交\n\n对于空头持仓，空头冻结是开空未成交，多头冻结是平空未成交\n\n所以要计算实际可平数量时候需要根据对应关系自己做好减去冻结的逻辑关系，比如判断可用多头就要用Position-ShortFrozen，实际持仓-对应的平仓挂单\n\n## **查帐户资金**\n\n通过查询函数ReqQryTradingAccount执行后，回调函数OnRspQryTradingAccount返回账户的资金情况\n\n账户的字段解释如下\n\n```python\ndict_ = {\n        '持仓盈亏': pTradingAccount.PositionProfit,\n        '平仓盈亏': pTradingAccount.CloseProfit,\n        '手续费': pTradingAccount.Commission,\n        '保证金总额': pTradingAccount.CurrMargin,\n        '可用资金': pTradingAccount.Available,\n        '权益': pTradingAccount.Balance,\n        '昨权益': pTradingAccount.PreBalance\n\t\t}\n```\n","tags":["计算机","ctp","金融"],"categories":["finance"]}]